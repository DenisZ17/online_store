/*
Установим зависимости:
- Установим Express - это фреймворк для написания бэкенда серверной части на Node.js (a Node.js это платформа, на которой можно делать бэкенд на JavaScript)
- Установим систему управления базами данных Postgresql и устанавливаем его модули pg и pg-hstore
- Устанавливаем sequelize - это технология которая позволяет связывать программный код с БД через функции
- Устанавливаем cors - это чтобы мы могли обращаться с нашего браузера на сервер
- Устанавливаем dotenv - чтобы задавать переменные окружения
- Установим nodemon - чтобы автоматическить перезапускать сервер
- В файле package.json запишем скрипт, который будет запускать приложение в режиме разработки: для этого в поле scripts пишем команду "dev": "nodemon index.js"
 */

// 8. Для того чтобы сервер мог считывать данный файл, нужно сюда импортировать config из модуля dotenv
require("dotenv").config();

// 1. при помощи require мы можем импортировать какие-то модули в файл, но в данном случае импортируем express
const express = require("express");

/* 9. Следующий этап сконфигурируем подключение к базе данных. Для этого создадим файл db.js и перейдем туда  */
// 9.7 импортируем объект из db.js
const sequelize = require("./db");

// 16. импортируем модели из models.js
const models = require("./models/models");

// 17.1 импортируем функцию cors
const cors = require("cors");

// 28.3.3 импортируем файл для работы с картинками и зарегистрируем его ниже
const fileUpload = require("express-fileupload");

// 20. импортируем основной роутер из routers/index.js, который связывает все основные
const router = require("./routes/index");

// 26. импортируем middleware
const errorHandler = require("./middleware/ErrorHandlingMiddleware");

// 28.3.3 импортируем path
const path = require("path");

// 3. Укажем порт на котором наше приложение будет работать
// 7. теперь получать порт из переменной окружения мы будем через process.env.PORT, если такая переменная не задана нам будет возвращать порт 5000
const PORT = process.env.PORT || 5000;

// 2.создадим объект вызвав функцию express, с которой и будет начинаться запуск приложения
const app = express();

// 17. настроим cors, чтобы мы могли отправлять запросы с браузера. Для этого импортируем функцию cors из пакета cors, который мы установили.
// 17.2 передадим эту функцию в функцию use
app.use(cors());

// 17.3 также в функцию use передадим express.json, чтобы наше приложение могло парсить json формат
app.use(express.json());
// 17.4 и попробуем создать первый get метод
// 17.5 первым параметром передаем url по которому этот запрос будет отрабатывать, а вторым функцию callback, которая принимает параметрами запрос и ответ (request и response)
/* -------- app.get("/", (req, res) => { */
// 17.6 в зависимости от ситуации мы можем на клиент возвращать разный статус. Код 200 говорит, что запрос произошел без ошибок. И в функцию json мы уже передаем тело ответа
/* ------- res.status(200).json({ message: "Working!!!" });*/
// 17.7 далее открываем Postman, указываем метод Get и вводим наш url - http://localhost:5000/ . Нажимаем SEND и внизу видим наше сообщение 'Working!!!' это означает что сервер работает
// 17.8 это была проверка поэтому 17.5 и 17.6 убираем
/* -----------});*/

// 28.3.3.2  -- 46.32
app.use(express.static(path.resolve(__dirname, "static")));
// 28.3.3.1 регистрируем express-fileupload
app.use(fileUpload({}));

// 21. Затем по аналогии вызываем функцию use и первым параметром указываем url по которому роутер должен обрабатываться. В нашем случае это - /api, а вторым параметром передаем сам роутер
app.use("/api", router); // далее откроем файл userRouter и проверим все ли работает
// 22. Сейчас мы функцию написали напрямую в роутере, но это является плохой практикой посколько роутер становиться слишком толстым. Логику по хорошему нужно отделять. Для этого создадим папочку controllers, а в ней для каждого роутера контроллер. Начнем с userController

// 27. -- ВАЖНЫЙ МОМЕНТ --- middleware должен регистрироваться в самом конце
app.use(errorHandler);

// 28. Научимся добавлять в базу данных объекты. Начнем с TypeController, переходим в данный файл

/* 10. Теперь необходимо вызвать функцию для подключения к БД. Мы назовем ее start, сделаем ее ассинхронной(поскольку все операции с БД являются асинхронными). Все это обернем в блок try-catch, чтобы отлавливать потенциально возможные ошибки */
const start = async () => {
  try {
    // 12. Теперь вызываем у импортируемого объекта функцию authenticate. С ее помощью будет устанавливаться подключение к БД, await обозначает, что функция асинхронная
    await sequelize.authenticate();

    // 13. Следующим этапом вызываем у этого объекта функцию sync. Эта функция будет сверять состояние БД со схемой данных, которую напишем чуть позже
    await sequelize.sync();

    // 10.1 вызов функции listen перенесем как раз в этот блок
    // 4. У app вызываем функцию listen в которой указываем какой порт должен прослушивать наш сервер, а вторым параметром передаем callback, который нам покажет что сервер стартовал
    app.listen(PORT, () => console.log(`Server started on port ${PORT}`));
  } catch (e) {
    console.log(e);
  }
};

/* 5. В терминале запускаем скрипт, который мы прописывали в package.json - npm run dev и запускаем*/
/* 6. Объявлять порт статично не очень хорошая практика поэтому всю конфигурацию выносим в переменную окружения. Для этого создадим файл .env и в него запишем 'PORT=7000'*/
// 11. Незабываем эту функцию вызвать чтобы сервер у нас запустился
start();

// 14. Составим диаграммы таблиц: (device, user, rating, type, brand, backet и т.д.)
// 15. Перенесем диаграммы в наш проект и реализуем схему того как данные будут храниться в БД. Для этого создадим папку models, а в ней файл models.js, где мы будем описывать модели данных
// 18. Теперь создадим каркас нашего приложения начнем мы с маршрутов по которым будут отрабатывать те или иные методы. Для этого создаем папку routes для типов, брендов, корзины, устройств и т.д., т.е. мы создаем отдельные файлы для них brandRouter.js, typeRouter.js и т.д. Также в этой папке создаем файл index.js, который будет объединять эти маршруты и будет основным роутером. Переходим в файл index.js в папке routes
// 29 Создадим модуль для генерации jwt токена и модуль для хэширования паролей (чтобы не хранить их в базе данных в открытом виде) -- npm i jsonwebtoken bcrypt и перейдем в файл userController.js
